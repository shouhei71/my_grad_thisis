■タイトル
サーベイ:大規模システムにおける故障検知

■概要
故障検知は、信頼できるシステム(ディペンダブルシステム)を構築する上で基本的なサービス(仕事)である。
大規模分散計算システムにおいては、故障検知を実現するのは、とてもむずかしい。さらに、
この状況の下でのQos(サービス品質)保証を行うことは難題である。この論文の目的は、二つある。
(1)異なる故障検知メカニズムを比較するための分類基準一式を提案すること
(2)これらの基準に基づいて、大規模分散システムにおける主な故障検知ソリューションをサーベイすること
である。


■intro

 自動的に故障検知を行うことは、信頼できるシステム(ディペンダブルシステム)を構築する上で基本的なサービス(仕事)である。
大規模なシステムにおいて、故障検知のQoS保証を行うことは、サイズのスケーラビリティと地理的なスケラービリティの観点から困難な
ことである。自動故障検知は、いつも決まって、アドホック(場当たりてき)なソリューションであり、商用ツールは、しば、
静的で動きがおそい。実装物は、概して、ほんの僅かな項目のQoS保証にしか言及していないし、
ユーザービリティを損ねてしまっている。

 大規模における故障検知についての研究はアクティブであるが、いまだ、いくつも欠点がある。
参照[9,14]は、フレキシビリティ性(様々な種のアプリケーションをサポートする)を示していないし、
つまり、一般的な故障しているノードを見分ける方法を提案できていない。
また、ある実装[4,9,12]は、限れられた環境を使用している。あるワークは、サイズスケーラビィティに言及していないし、
またあるワークは、ネットワークの変化に適応できないものもある。
[10,15]では、故障検知の分野の状況について、簡潔に議論している。
参照[16]では、故障時間、判定ミスの割合、ネットワーク帯域、メッセージロスにわたって、
数学的に、実験的に、アルゴリズムを比較している。
参照[6]では様々な見積りに対しての実験的な評価と安全に分散プッシュ故障検知を利用する際の限界点を提案している。
論文[10]では、グリッドに対する呼称検知に関する調査を提供しているがその限られ性質しか使用していない。
さらに、メッセージ爆発とスケーラビリティは、一緒のレベルで扱われている。
論文[6]は、異なる実装の選択に焦点を当てている。

--------------------------------------------
■コメント
・参照[16]
-俺のワークを包含しているかも。
・参照[6]
-評価の部分、限界の見極め方を見たほうがいい。


--------------------------------------------


この状況下でこの論文は、異なる故障検知メカニズムを比較するための分類基準一式を提案すること、
そして、これらの基準に基づいて、大規模分散システムにおける主な故障検知ソリューションをサーベイすること
を提案する。
この論文は、６セクションから構成されている。
セクション２は、故障検知についての定義を与える。
セクション３では、異なる故障検知メカニズムを比較するための、分類基準一式を提案する。
セクション４では、大規模環境での故障検知についての、主なQoS基準を提案する。
セクション５では、最も良い大規模環境での故障検知の対応法についての議論を提案し、
セクション６では、結論を述べる。



■セクション２: 故障検知についての背景
　故障検知[3,4]は、故障しているノードについての情報を集めるプロセスのことである。
これらは、(故障が)疑わしきノードと、モニターしているノードのリストを管理していて、
またそれらは、スタティックかもしれないし、ダイナミックかもしれない。
ダイナミックなリストは、絶えず変化するノード群を管理していていることであり、
これは、ネットワークの激しい変化に対しての対応能力を考慮すると、もっと現実的なモデルといえる。

　故障検知は、ハートビートとPingという二つのタイプのキープアライブメッセージを使って、故障しているノードを判断する。

ハートビートは、モニターしているプロセスから故障検知を行うプロセスに定期的に送られてくるメッセージのことである。
このメッセージで、対象ノードが故障していないことを知らせる。
もし、ハートビートが制限時間内に届かなければ、故障検知を行うプロセスは、このノードは故障していると"疑う"(判断する)。

Pingは、故障検知を行うプロセスからモニターしているノードに継続的に送られるメッセージのことである。
故障検知を行うプロセスは、その応答として、Ackを受け取るを取ることを準備している。
もしキープアライブメッセージが届かなければ、精密な調査(タイムインターバルで区切られた一連のメッセージなど。)が行われ、実際にプロセスが故障しているかどうかが確かめられる。

実際のところメッセージ到達の遅れは予測できないので、非同期的な環境下で故障しているノードと健全なノードを見分けるのは困難である。
よって、故障検知の問い合わせに対して返答がないプロセスは、「疑わしき物」として扱われるのである。

■セクション３: 大規模環境での故障検知の分類
 このセクションでは、大規模環境での故障検知を比較するための分類基準一式を提案する。これらの基準は、Table1に要約されている。



A.集中型と分散型
 集中型の故障検知は、単体で一枚岩的なモジュールで様々なプロセスをモニターすることが可能である。
(+)管理しやすいが、
(-)単一故障点がある
(-)潜在的なボトルネックになりやすい。

分散型の故障検知は、
(+)これらの欠点を避けられている。
一連の故障検知モジュール群とみなされていて、各モジュールにシステムの中で異なるプロセスが割り当てられている。
リクエストが来るとすぐに、それぞれ各モジュールが故障が疑わしいノードのリストを提供する。

B.Push VS Pull
 キープアライブメッセージ[7]に関して、Pull型とPush型の二つの切り口がある。

Push型アプローチは、ハートビートを用いており、制御フローと情報フローの方向は同じである。

Pull型の故障検知は、そのフローは逆である。Pull型の故障検知においては、Pingメッセージが使われる。
ハートビートは、Ping故障検知と比較して半分のメッセージのやりとりしか必要ないこと、タイムアウト遅延の見積もりが
片道のメッセージで判断ができるので、アドバンテージがあると述べる著者を紹介している。
Ping故障検知の一つのアドバンテージは、時間の制御が故障検知をおこなうプロセスにおいてだけ実行されることである。

-----------------------
■コメント
pull,pushとheartbeat,PIngの関係性がピンと来ない

-----------------------

C.アクティブ VS パッシブ
参照[7]は、アプリケーションを利用するかどうかで故障検知を分類している。
アクティブプロトコルは、キープアライブメッセージを継続して送信、受信する。
Lazy、パッシブなプロトコルは、アプリケーションメッセージを利用して故障検知をおこなう。
もしデータ通信が頻繁に発生するならば、故障検知に十分であると言える。

しかしながら、[16]は、パッシブプロトコルが適切でない状況について言及している。これらのシチュエーションでは、
アクティブプロトコルが必要になる。

-----------------------
■コメント
・[16]は、パッシブプロトコルが適切でない状況とは？
・Chordはルーティングテーブル

-----------------------


D. 土台(?: baseline) VS 共有(?: シェアリング)
 ノードの生存情報について共有するかどうかに関して、土台(?: baseline)と共有(?: シェアリング)の二つに分類することができる。

共有アプローチでは、故障検知するモジュールはモニターしているノードの生存情報について他のモジュールと共有する。
ネットワークトポロージを考慮して、概して近隣ノード群が使われ。
共有アルゴリズムでは、交換される情報の種類、これらが維持するキープアライブ状態の量において異なる。

土台アプローチでは、それぞれのモジュールは、独断で故障が疑われるノードについて判断を下す。

E. 適応可能な値 VS 一定の値
 キープアライブの頻度、タイムアウト、その他の時間は、適応可能(Adaptive)な値にするか、一定の値にするかで分類できる。

一定の値は、
(+)実装しやすい。
なぜならば、それぞれのノードにおいて一回計算されるだけだからである。例えば、ノードがシステムに参加したときである。
(-)しかし、一定の値では、ネットワークの激しい変化のまえでは、効率性は制限されてしまう。

適応型の故障検知は、[2,4,5,11]で提案されている。[11]では、アイディアは、送らせたタイムアウトを使うことで、新しいハートビートの到着時間を
予想することである。
(-)割合とタイムアウトを計算することは、単純なたすくではない。
またいくつかのネットワークインフォーメーションを含めなければいけない。
アダプティブ、一定の比率は、数学的な公式で計算することができ[4,6,15]、または、代わりに自己学習的な方法を用いることもできる。

F. グローバルな時間の値 VS ローカルな時間の値
 時間に関するその他の事柄は、個々でおこなうか、グローバルに行うかである。
単純なアプローチは、すべてのノードに対して、グローバルにキープアライブメッセージを出す頻度を利用することである。
もしすべてのノードが同質で、同じセッションの存在時間を設けているならばこのアプローチは効果的である。
一方、もしノードが同質でなかったら、個々のノードがそれぞれが自身の頻度を計算することができる。

-----------------------
■コメント
・rateがイマイチ？

-----------------------


 他の基準を紹介する前に、我々は、大規模環境での故障検知のオペレーションフレーズについて説明する。
「正常」,「伝搬」、「再構成」のフレーズである。
◇正常
故障検知モジュールはキープアライブメッセージをモニターするノードに「正常」フレーズでおくる。

◇伝搬
故障が検知されたとき、「伝搬」フレーズがスタートし、故障情報がその他のモジュールに伝えられる。

◇再構成
「再構成」フレーズは「伝搬」フレーズが終了したときにスタートする。
また、ローカル「再構成」とグローバル「再構成」の二つフレーズから構成される。
ローカル「再構成」は、現存のモジュールがその故障を修理したときに、行われる。
例えば、故障検知は、グループからノードを取り除くことができる。
グローバル「再構成」は、故障部位についての情報が他の故障検知モジュールに伝搬されたときに行われる。
これにより、他のノードは、システム情報の変化を反映させることができる。

大規模環境での故障検知では、二つのパフォーマス問題が存在する。モニタリングと、伝搬パターンである。
迅速な伝搬は、システムの整合性(一貫性)を維持するのを助けると同時に、効率的なモニターリングは、検知時間を短縮する。

G: モニターリングのパターン
 モニタリングのパターンは、「正常」フレーズにおける故障検知モジュールとモニターされているノードにおけるコミュニケーションに関連している。
モニタリングのパターンは、全対全型、ランダム型、近接ベース型の３つがある。

◇全対全型の故障検知
では、各モジュールがキープアライブメッセージをすべてのモニターしているプロセスに送信する。
(+)実際、構成するグループのメンバーが少ない時、このアプローチは、効率的に機能する。
(-)しかし、スケーラビリティは制約される。もし、プロセス数が膨れ上がったら。なぜならネットワークトラフィックが大規模になるからである。

◇ランダム型の故障検知
各ノードは、リストを管理している。リストには、故障検知につかうための各アドレスと、時間の値がメンバごとにある。
グループ内の各ノードは、ランダムにほかのｋノードを選択して、キープアライブメッセージを送信する。
Gossiping protocolはハートビートをもとにランダムに故障検知を行う特殊な種である。(具体的なものを挙げるための言い回しか？)

ゴシッピングはグループ数が少ないときはとても効率的であり、
グループ数が多いときには、複数(multi-level,複数カテゴリできる切り口があるくらいか。)のバージョンがある。
ランダムな故障検知が、モニターしているノード同士で、ランダムに行われる、あるいは定期的なコミュニケーションによって、
(+)スケーラビリティを改善し、
(+)検知時間の短縮
故障検知時間は、ランダムに選択されることの確率に依存する。

◇近隣ベース型の故障検知
各プロセスはキープアライブメッセージを近隣ノードに送る。
コミュニケーションを制限し、ローカリティ性を考慮することで、パフォーマンスは、改善される。
近隣ノードは、故障を検知しない限り、時間がたっても静的に変化しない。
この場合、故障したノードをのぞいたり、新しい近隣ノードを選択するために「再構成」フェーズが必要である。
また、ネットワークインフォメーションは考慮されなければならない。

-----------------------
■コメント
・グループ数が多いときの、gossip protocol のバリエーションをしらべよう。
(関連研究になりそうだね。)
-----------------------


H.故障伝搬
 あるノードが故障していると判断されたとき、この情報は、他のモジュールに伝搬されなければならない。
故障の伝搬は、大規模環境では、非常に時間がかかるもので、伝搬にかかる時間を短縮するために、さまざまなアプローチが提案されている。
全対全,ランダム,(リング、)円形状の空間、階層構造である。

◇全対全 伝搬パターン
故障は、瞬時にすべての故障検知モジュールに伝わる。
もし、故障、チャーンが頻繁に起こると、ネットワーク通信量が一気に跳ね上がる(intense)
この場合の故障検知の実装は、パフォーマンスの理由から、IPマルチキャストを利用するのがよいかもしれない(?)

◇ランダム 伝搬パターン
モジュール、モジュール群が選択されて、現存する故障検知モジュールから故障についての情報を受け取る。
(+)コミュニケーションは全対全伝搬パターンにくらべて、少なくて十分であるが、
(-)伝搬にかかる時間は、別のノードに選択される割合に依存している。


◇円形状の空間 伝搬パターン
円形状の空間の故障検知では、仮想的なリングにノード群を配列する。
コミュニケーションは、近接するノード群だけで行われる。
(-)それゆえ、新しいノードが追加されたり、リングからノードが離脱したときには、
近接ノードは、再構成されなければならない。
(-)もうひとつの欠点は、仮想的なネットワークトポロジに対して、仮想的なリングをマッピングしなければならないことである。
これは、そんなに簡単なことではない。
(-)また、故障伝搬は、大きなリングでは非常に時間がかかる。
-----------------------
■コメント
・ring型がディスられているw
-----------------------

◇階層構造 伝搬パターン
階層的な故障検知では、ノード群をマルチ階層に配列し、少ないグループのモニタリングに分断する。
(+)故障は、ツリーにそって、報告されるため、スケーラビリティが改善される。
(+)階層的な故障検知は、効率性のためにネットワークインフラ酵素を考慮に入れる。
(+)また、よく一般的に大規模分散システムにおいて用いられていおり、
他のアプローチ(伝搬パターン)で動作しているスモールグループに連結している。


■セクション4: 故障検知のQoS指標
大規模環境における故障検知のQoSは、
一貫性、パフォーマンス、ダイナミックな環境に対する適応、スケーラビリティと関連している。(である。的な。)

A.一貫性の指標

 故障検知は二つの主な分類可能な性質がある。正確性と、完全性である。[3]
正確性は、故障検知が犯すミスに限定し、
一方で、完全性は、故障検知が最終的にノードが故障していると疑うことに言及している。
参照[4]は、故障検知のQos仕様のための主な指標と推論の正確性の指標を提案している。
完全性に関連している主な指標は、検知するまでの時間と故障検知にかかる時間である。
正解性と関連している二つの指標は、ミスの再発性、ミスが発生し続けている期間である。

推論される正解性の指標は、平均ミス率、クエリーの正確性の確率、よいレスポンスタイム、良い転送タイム？

-----------------------
■コメント
・意味ぷー
-----------------------


B.パフォーマンス関連の指標
 パフォーマンスの指標は、故障検知によって使われるリソース(ノード、ネットワークなど)と関連がある。
主な指標は、CPUロード,メモリー消費、ネットワークバンド幅である。
故障検知は、これらのリソースの消費を制限するかもしれないし、増加させるかもしれない。
例えば、バンド幅の消費を減らすために、故障検知は、ネットワーク越しに送るメッセージ数を制限するかもしれない。

パフォーマンス指標は、故障検知が影響をあたえることができない(つまり、間接的に影響を与える)事柄もふくんでいる。
これらの指標には、ノード故障率、ノード故障までの時間、平均復帰時間、平均故障間隔、平均ノード生存時間、
また、遅延、メッセージロス、リンク故障率、リンク故障までの時間などのネットワークの振る舞いにも関連している。

C.適応性についての指標

 このカテゴリーは、故障検知がダイナミックなシステムの振る舞い(変化)に対応する能力に関連する指標を包含している。
大規模環境の故障検知では、高いチャーン率、爆発的なメッセージ数の増加、メッセージロス、ヘテロな環境、柔軟性に適応できなければならない。
適応性に関する指標は、ダイナミズム関連と、柔軟性に関連する指標の二つのグループに分類される。

ネットワークダイナミズムに関連する指標は、故障検知が直接影響を及ぼせないようなパフォーマンス関連の指標に記述されている。
フレキシビリティについての指標は、グローバルなあるいはローカルのkeep-aliveメッセージの割合、一定or変化するkeep-aliveメッセージの割合である。

-----------------------
■コメント
・最後の１文に分かれることから意味がわからん、
-----------------------


D.スケーラビリティに関する指標
 スケーラビリティは、少なくとも以下に挙げる指標のうちの一つから定義される。
サイズスケーラビリティ、地理的なスケーラビリティ。スケーラビリティについての指標には、グループサイズや遅延が含まれている。


■セクション5: 議論
前述した指標と分類に基づいて、このセクションでは、我々は大規模分散環境のための主な故障検知ソリューションについてサーベイを行った。

-----------------------
■コメント
・しれっと「分散」って言葉がw
-----------------------


A.生存情報を共有して、検知時間を改善する。

 故障検知時間は、近隣ノード間で生存情報を共有することで改善される。つまり、
最初に故障を検知したノードが他のノードにアナウンスするのである。
[16]において、ネットワーク上の2000ノードで実験していみたところ、
近隣のノードの数は増加するにもかかわらず、検知時間はほとんど変わらなかった。
加えて、同じ著者は、情報共有することで、高いチャーン率に適応するのを助けることができると主張する。

B.適応性についてのソリューション
 大規模のネットワークにおいて、[1,8,15]の適応性アルゴリズムは、一定のタイムアウトを設けるアルゴリズムよりも、
効果的であることを示した。これらのアプローチは、様々なアプリケーション必要制約やネットワーク変化に対応することができるｄ。

適応性のアプローチは、いくつかの明らかな欠点を持っている。
・故障検知でのタイムアウトのチューニングをおこなう適切なメカニズムをどうやってみつけるか？
・どのようにキープアライブメッセージを送らなければならない頻度をどう選択するか？(頻度はどう選ぶ？)

参照[15]は、ルーターを用いて、現在のネットワークトラヒックをもとに、大規模環境でのハートビートに動的に対応することを提案している。

-----------------------
■コメント
・???
-----------------------

著者は、このソリューションはレスポンスタイムの短縮、良いスタビリティ性、頑強性のメリットがあると主張する。
しかしながら、ルーターはボトルネックになりかねない。
もっと興味深いソリューションは、故障しているノードについての疑わしい(故障可能性がある)情報を使った正確な故障検知である。
現在、大規模環境においては、実験はない。しかし、これは、有望なソリューションになるだろう。
なぜなら、これは提供される情報のQoSれべるについて決定することを目的としたアプリケーション(適用)であるからである。

C. グローバル ローカルのタイムアウトのあたいについて

 大規模環境において、古語のプロセスのタイムアウトを維持し、計算し、チューニングすることは、受け入れられないだろう。
一方、ローカルとリモートのプロセスで同じタイムアウト(制限時間)を設けることも受け入れられない。
もし大規模環境で、故障検知がいくつかのノードを同時にモニターできるような状況が受け入れられないなら、ハイブリッド型の
アプローチが小さなグループでモニターしているプロセスを分水する。そして、各グループではキープアライブ率を取り入れる。

-----------------------
■コメント
・???
-----------------------


D.故障or ビジーなノード
 概して、故障検知は、プロセスレベルで実装されている。１マシンあたり１プロセスでクラッシュ故障モデルに沿っている(?)
その結果、ビジーなノードが故障しているノードと区別がつかない。なぜなら、二社共に、制限時間をこえる前に故障検知の応答に対して、
答えることができないからである。
[5]では、故障検知は、プロセスレベルではなく、アプリケーションレベルで適用されている。
このアプローチでは、ノードは、あるローカル故障検知によってモニターされているさまざまなアプリをサポートする事ができる。
これは、各アプリケーションに事前に知らされた一定のQoSレベルを満足できる。

-----------------------
■コメント
・後半は??
-----------------------

E.Gossiping Protocol

 Gossiping protocolは、ネットワークバンド幅が全対全プロトコルよりも狭い。
二つ目に[13]、マルチレベルのゴシッピングは、メッセージ爆発を防ぎ、メッセージロスに対処できる。
Gossiping protocolは、またネットワーク構造を考慮に入れないので効率的である。
しかしながら、著者は[5,16]いくつかの欠点があると報告している。例えば、たくさんのノードがクラッシュしたときに、
検知時間は、基本的な(フラットな)プロトコルでは非常に時間がかかる言われている。加えて、開発は、ランダム機能の選択に注意を
払わなければならない。

適切でない機能であるば、あるノードは、ランダムに多く選ばれ、あるノード群が他のノードに比べて古い情報を保持することになってしまうだろう。

F.階層的なプロトコル

 階層的なプロトコルは大規模環境においてとても効率的だと証明されている。これらは、円形状空間の故障検知や、全対全の故障検知、ランダムプロトコルに適用することもできる。
例えば、リンク上の空間に配置されるすべてのノードに対しての故障の伝搬は、メッセージがリングに沿って送信されるので,(?)
大きなリングでが非常に時間がかかる。
 迅速に故障の伝搬をおこなうために、リングは、スモールグループに分割されることができる。またリング毎にリーダーがいる。
もし故障がグループ内のノードによって検知されたら、そのグループリーダーは、その他のグループリーダーに故障について知らせる。
それぞれのグループリーダーは、階層の上位にいて、そのグループメンバーに故障のことを知らせる。
 マルチレベルゴシッピングは[13]、階層構造のローカルグループに接続し、リーダーが故障するたびに新しいリーダーの選挙を避けている。(?)

IPアドレスがスモールノードを分けるのに使用される。ほとんどのモニターメッセージは基本的なモニタープロトコル(つまり、ランダムプロトコル)によって小さなグループ内で送られる。一方、グループ間で送られるモニターメッセージは殆ど無い。
IPアドレスをしようすることは、階層構造を、ネットワークトポロジーを意識しないことになる。なぜなら、スモールグループ内でのネットワーク分割は、動的に行われるからである。

-----------------------
■コメント
・全体的に??
-----------------------

● 結論
 近年、故障検知において実験的研究が、大規模環境を考慮しながら行われてきた。
しかしながら、実践的なモニタリングや、故障検知ツールはいまだ必要である。
Qos保証を与えることは困難なままである。
それに対するソリューションは、可能なかぎりでしゃばらない(本業を邪魔しないか？)こと、ネットワークダイナミズム、スケーラビリティ、
パフォーマンス、一貫性、ヘテロな状況の適応、アプリケーションフレキシビリティなどの事柄を考慮しなければならない。

 大規模環境にて、モニターするノードに対して、適切な制限時間の値を決定することは、いまだ困難なタスクである。
現在のソリューションは、つねにシステムをスモールグループに分類し、故障検知のプロセスの一貫性を改善するために近接同士の情報を使用することである。今後の課題としては、マルチアプリケーション環境の故障検知について調査することである。








