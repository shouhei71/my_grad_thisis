%%%%
\chapter{測定手法}
\section{Cassandraの概要}
 ・メンバーシップ周り？\\
 ・seedの説明\\
 ・データ保管部分の解説\\
 ・ある特定のポートで通信を行なっている。\\
・cassandraは,IPアドレスのみでノードを判定している。\\
 
\section{Cassandraの軽量化}
(TODO1:具体的に数値を細かくだそうか。)
(TODO2:具体的に数値は環境依存だが、どう書く？)
実験を行うにあたって物理リソースの都合上、1台あたり複数の Cassandra ノー ドを起動する必要があった。デフォルトの設定では、１ノードのCassandra起動するためには、データを全く保持していない状態で、スレッド数が130、メモリー使用領域が、150M程度消費する。1台あたり多数のノードを立ち上げるために、データ保持部分のプログラムの改変と、設定ファイルのパラメータの調整を行った。
\subsection{プログラムの改変}
(TODO1:具体的に数値を細かく?)\\
Cassandraでは、何もデータを保持していない状態であっても,システム管理のためのテーブルを保持している。また、時間が経つと徐々にOnmemory上にmemtableとかが増えてしまことで、メモリー使用量域がかさむ。以下の点を踏まえて、メモリー使用領域を減らすために改変を加える。\\
私の実験では、実データがどのようなものかは関係がない。そこで、実際のデータを保存するのではなく、データサイズだけを保管するように変更した。その結果メモリー使用量域が減った。
また、時間が経過しても増加する量が抑えられた。

\subsection{設定ファイルのパラメータ調整}
(TODO2:現状は、非常に怪しい[column familyの定義を減らしたのが聞いてるだけってのもありうる。])\\
Cassandra１ノードで使用するスレッドは非常に多い。できるだけスレッド数を減らすために設定ファイルを変更した。具体的には、Cassandraが起動時に呼び込むstorage.confというファイルである。変更したパラメータは、\\
\begin{itemize}
\item $concurrent_reads$ : いくつまで同時読み込みを許すしきい値
\item $concurrent_writes$: いくつまで同時書き込みを許すしきい値
\end{itemize}
このパラメータは,Cassandra(の？)で使用するスレッド数に直結するので、この数を32 - > 2 ,132 - > 2と減らすことで、全体のスレッド数をを130 ->  100に落とした。

\section{実験シナリオ}
実験では、マスターとなるマシンを１台とワーカーとなるマシンを１０台を用意した。マスターの役割は、通信量計測の開始・終了,Cassandraの起動,計測した記録の解析をワーカーに指示すること、最終的な通信量の推定を行うである。一方、ワーカーの役割は、通信量の計測、Cassandra ノー ドを起動すること、通信量の解析である。また、	1台あたり複数のCassandraノードを立ち上げる必要がある。Cassandraノードの立ち上げ方は、30 秒ごとに、1台あたり 10 ノードの Cassandra を一度に起 動し、これを目指す台数に達成するまで続ける。最初の Cassandra ノードを起動した瞬間から各マシンで10 分間の通信量を計測した。\\計測後に各マシンで通信量を解析し、マスターとなるマシンに解析結果を送信する。マスターは、送られて通信量から合計値を出し、Cassandraで発生する通信量の推定を行う。\\
マスター、ワーカーで実行するプログラムは、シェルスクリプトでプログラムを書き、各ワーカーへの指示は、GXPを利用して制御した。また、パケット情報の解析には、java,R,シェルスクリプトを使った。\\
\subsection{実験環境}
以下に実験環境を示す。
\begin{itemize}
\item Cassandra 0.6.6	
\item OS Linux	 2.6.35.10 74.fc14.x86\_64
\item CPU: 2.40 GHz Xeon E5620 × 2
\item Java 仮想マシン: Java SE 6 Update 21
\item メモリー: 32GB RAM
\item ネットワーク: 1000BASE-T
\end{itemize}
\subsection{計測方法について}
計測にわたって、いくつか工夫した点を紹介する。\\
\begin{itemize}
\item IPエイリアシングを利用し、プライベートネットワークを構築した\\
Cassandraのメンバー管理では、IPアドレスでメンバーを認識する。つまり、今回の実験ように、１マシンあたり複数ノードのCassandraを立ち上げようとすると、不都合が生じる。\\
そこで、IPエイリアシングを使用して仮想アドレスを作成し、Cassandraノードごとに割り振ることにした。その結果、同じマシン上に立ち上がったCassandraマシン同士の見分けがつき、不整合が起きなくなった。\\
さらに、通信量の測定の際には、ノイズを防がないといけない。ここでノイズとは、Cassandraノード以外から要求されるリクエストのことである。具体的には、ARPとか、PINGなどのリクエストである。これらが誤って計測結果に加わることを避けるために、IPエイリアスリングを行うと同時に、
プライベートネットワークを構築した。このネットワークに参加しているのは、Cassandraノードだけである。この作業で、プライベートネットワーク内で飛び交うパケットのみを取得すればよく、ノイズが減らすことができる。\\具体的には、10.20.0.0/16のネットワークを用いた。さらにCassandraノードがどのマシン上で起動しているかを判別しているために、クラスタ番号をnとして、
10.20.n.0/24なるサブネットを仮想的に設けた。n=19のとき、10.20.19.1 〜10.20.19.254までの仮想アドレスを作成した。

\item tcpdumpの使用\\
通信量の測定は、tcpdumpを使用した。上述したように、Cassandra Node同士のやりとりは、プライベートネットワーク上で行われるため、このネットワークをまたぐすべてのTCPパケットのサイズを記録した。\\具体的には、
sudo tcpdump -i dst net 10.20.0.0/16 ..............................
というコマンドを実行した。\\

\item ユーザーのリソース制約を外す\\
特に、Cassanddradはメモリー使用量域、使用するスレッド数が多いため、ユーザーに与えられてユーザーリソース制約にぶち当たることがある。今回プロセス数、メモリー数の制約を外した。
\item 同じマシン上で動作しているCassandraノード同士の通信は取得できない。\\
一方、この測定方法では同じマシン上で動作しているCassandraノード同士の通信は取得できないことに留意したい。

\end{itemize}

\section{通信量の測定について}
しかしながら、この計測方法では同じマシン上でのCassandraNode同士の通信を計測することはできない。だが、計測した総通信量からCassandra Nodeで発生する総通信量を計測できることを示す。\\
ここで、一つ仮定を立てる。\\
・任意のCassandra Node同士の通信量は平均すると同じ！(言葉をおきかえる!)\\
この仮説をもとにすると、n台の各マシンでm台のcassandra nodeを起動したとする。
(つまり、合計 n × m台のCassandraノードを立ち上げたとする)さらに、上のように、各マシンでtcpdumpを使用して計測した得られたトラフィックの合計をTとおき、Cassandra nodeで発生するそう通信量TTとく。(n-1) * m台のcassandra nodeで発生している通信量が Tであるので、仮説を使うと、n * m台の場合は、\\
	TT = T * (n * m ) / ((n-1) * m ) = T * n / (n-1)\\
となる。
具体的に、n = 10台の時について、図を使いながら解説する。
(図を使おう)



