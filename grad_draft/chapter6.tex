%%%%

\chapter{Cassandraの軽量化と測定手法}

\section{Cassandraの軽量化}
通信量のスケーラビリティを評価するためには、Cassandraノードを多数起動する必要がある。
しかしながら、物理リソースの都合上10台のマシンのみが利用可能であった。
そこで、マシン1台あたりに多数のCassandraノー ドを起動することが必要になった。

そもそもデフォルトでは、Cassandraは1マシンで複数ノードが起動できるような仕組みになっていない。
そこで、複数ノード起動ができるように通信のポート番号の変更するなどした。
さらに一度に多数ノードが起動できるようなスクリプトを作成した。

しかしながら、1ノードのCassandraを起動するために、デフォルトの設定でデータを全く保持していない状態で、スレッド数が130、メモリー使用量が120 Mbyte程度とリソースを多く消費する。(以後、$G = 2^{30}$ $M = 2^{20}$、$K= 2^{10}$とする)
またクラスタを構成した際には、さらに１ノードあたりのリソース消費量が増える。
多数ノードのCassandraを起動するには、1ノードを起動するためのリソースの消費を抑える必要があった。
そこで、Cassandraデータ保持部分のプログラムの改変と、設定パラメータのチューニングを行った。
\subsection{プログラムの改変}
Cassandraは、データを保持していない状態であってもシステム管理のためのテーブルを保持する必要があり、メモリー使用量がかさむ。メモリー使用量を減らすためにプログラムに改変を加える。
gossipの通信量を測定する実験では、データを読み書きするオペレーションはない。
そこで、実際のデータを保存するのではなくデータサイズだけを保管するように変更しメモリー使用量を削減した。

\subsection{設定ファイルのパラメータ調整}
\paragraph{JVM最大ヒープサイズの制限を変更}
CassandraはJava仮想マシン(JVM)上で動作する。多数ノードを起動するために、JVM最大ヒープサイズの制限をデフォルトの1 Gbyteから160 Mbyteに変更した。
%この変更でCassandraノード起動時のメモリが120Mから89Mに減少した。
\paragraph{設定ファイルのパラメータ調整}
設定ファイルにて、同時に読み込みを許す最大値、同時書き込みを許す最大値を制限することで
スレッド数を減らした。

また、これらのパラメータの調整も、gossipの通信量を測定する実験では、直接関わらないパラメータである。
これらの調整により、1マシンあたりCassandraを最大65ノードまで起動することができた。
%このパラメータは, Cassandra読み込みで使用するスレッド数に直結するので、この数を32 - > 2 , 132 - > 2と減らした。この値は、Cassandraが食らうたーGossipProtocolの通信量を測定する実験では、直接関わらないパラメータであるので数値を改変しても問題はない。このパラメータは, Cassandraで使用するスレッド数に直結するので、この数を32 - > 2 , 132 - > 2と減らした。この値は、Cassandraが食らうたーGossipProtocolの通信量を測定する実験では、直接関わらないパラメータであるので数値を改変しても問題はない。２台起動してクラスタを構成したときの各マシンのスレッド数が121 ->  85に減少した


\section{測定手法}
非集中型クラウドストレージのスケーラビリティを評価するために以下の実験を行った。
\begin{itemize}
\item 実験1:gossipの通信量の測定
\item 実験2:データ読み書きの通信量の測定
\end{itemize}

\subsection{実験1:gossipの通信量の測定}
実験1ではgossipの通信量の測定を行った。実験では、マスターとなるマシンを1台とワーカーとなるマシンを10台を用意した。ワーカーマシンをNode1, Node2, ...Node20と名付ける。マスターの役割は、通信量計測の開始・終了、Cassandraノードの起動、計測した記録の解析をワーカーに指示し、最終的な通信量の推定を行うことである。
一方、ワーカーの役割は、通信量の計測、Cassandra ノー ドを起動、通信量の解析である。また、1台あたり複数のCassandraノードを立ち上げる必要がある。
Cassandraノードの立ち上げ方は、30秒ごとに、1台あたり10ノードのCassandraを一度に起動し、これを目指す台数に達成するまで続ける。
最初のCassandraノードを起動した瞬間から各マシンで10 分間の通信量を計測した。

計測後に各マシンで通信量を解析し、マスターとなるマシンに解析結果を送信する。
マスターは、送られて通信量から合計値を出し、Cassandraで発生する通信量の推定を行う。

マスター、ワーカーで実行するプログラムは、シェルスクリプトでプログラムを書き、各ワーカーへの指示は、GXP \cite{GXP}を使用して制御した。GXPは、同じコマンドを多数のホストで並列に実行するための制御ツールである。また、パケット情報の解析にはJava, R, シェルスクリプトを用いた。

\subsection{実験2:データ読み書きの通信量の測定}
実験2ではアプリケーションを用いてデータの読み書きを行ったときの通信量の測定を行った。
実験シナリオは、マスターとなるマシンを1台とワーカーとなるマシンを5台を用意し、実験1と同様の手順でCassandraの起動、通信量の測定を行った。

データを読み書きするアプリケーションとして、Yahoo! Cloud Serving Benchmark (YCSB) を使用した。YCSB  \cite{YCSB}はYahoo! Researchが開発したクラウドストレージ用のベンチマークである。

\subsection{計測方法について}
実験1、実験2の計測にあたっていくつか工夫した共通の点を紹介する。

\paragraph{ユーザー、プロセスのシステムリソース制約を外す}
通常のオペレーションシステムでは、1ユーザ、1プロセスに共有のシステムリソースを占有されないように管理がされている。具体的には、1ユーザが同時に実行出来るプロセス数、ファイル・ディスクリプタの数であったり、ユーザーが実行するプロセスにおいては、仮想メモリーの使用量、物理メモリーの使用量などについて制限がされる。

\begin{figure}[h]
  \begin{center}
  \includegraphics[bb=0 0 337 255, width=10cm]{img/ulimit-before.png}
  \caption{リソース制限変更前}
  \label{fig:ulimit_b}
    \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
  \includegraphics[bb=0 0 337 255, width=10cm]{img/ulimit-after.png}
  \caption{リソース制限変更後}
  \label{fig:ulimit_a}
    \end{center}
\end{figure}


我々の実験環境では、数ノードでクラスタを構成するだけで1ノードあたりスレッド数が130程度必要であり、クラスタを構成するノード数が増加するとさらに増加する。
Linuxのデフォルトの設定では、1ユーザが同時に実行出来るプロセス数は1024であるので、Cassandraを7ノードまでしか起動できなかった。 (図\ref{fig:ulimit_b}) 

そこで、Linuxのユーザーリソースを決める設定ファイルを編集し、1ユーザーのリソース制限、1プロセスのリソース制限を緩和した。 (図\ref{fig:ulimit_a}) 
その結果、多数ノードの起動が可能になった。

\paragraph{NFSを利用した書き込みをできるだけ控える}
概して一度に多数ノードを起動するときは、実行ファイルを共通にして起動することが多い。
すなわち、NFS上に共通の実行スクリプトを保存し、実行時に読み込むことが多い。
しかしながら、一度に非常に多数のNFSを通じた読み込みが発生すると、上手くアクセス出来ないことがある。
そこで、各マシンのローカル上に実行ファイルを保管し起動時にそのファイルを読み込むようにした。

\begin{figure}[p]
  \begin{center}
  \includegraphics[bb=0 0 637 759, width=15cm]{img/ipaliasing.png}
  \caption{{\tt ifconfig}の実行結果}
  \label{fig:ifconfig}
    \end{center}
\end{figure}

\begin{figure}[!h]
  \begin{center}
  \includegraphics[bb=0 0 719 562, width=15cm]{img/ring.png}
  \caption{Cassandraクラスタを構成したときの様子}
  \label{fig:ring}
    \end{center}
\end{figure}

\paragraph{IPエイリアシングを利用し、プライベートネットワークを構築}
Cassandraのメンバー管理では、IPアドレスでメンバーを認識する。
今回の実験のように１マシンあたり複数ノードのCassandraを立ち上げようとすると、不都合が生じる。つまり、同じマシン上で立ち上げたCassandraノードは、他のマシンからは同一のノードと認識されてしまうのである。

そこで、IPエイリアシングを使用して仮想アドレスを作成し、Cassandraノードに割り振ることにした。
その結果、同じマシン上に立ち上がったCassandraマシン同士の区別が可能になり、不整合が起きなくなった。

さらに、通信量の測定の際にはノイズを防がないといけない。ノイズとは、Cassandraノード以外から要求されるリクエストのことである。
具体的には、ARPやsshなどのパケットのことである。
これらのパケットを誤って計測してしまうことを避けるために、IPエイリアスリングを行うと同時に、プライベートネットワークを構築した。
よって、このネットワークに参加しているのはCassandraノードだけである。
つまり、プライベートネットワーク内で飛び交うパケットのみを取得することが簡単にできる。

具体的には、10.20.0.0/16のネットワークを構築した。
さらにCassandraノードが物理的にどのマシン上で起動しているかを判別しているために、実マシン (Node11, Node12, ..., Node20) 上のノード番号$n$を使用し、Node[$n$]上で起動するマシンに仮想的に10.20.$n$.0/24なるサブネットを設けた。
例えば、実マシンNode19で起動するCassandraノードに割り当てられる仮想アドレスは、10.20.19.$x$  ($1< x < 254$) となる。
図\ref{fig:ifconfig}がプライベートネットワークを構築後に{\tt ifconfig}コマンドを実行したときの実行結果で、このネットワーク内でCassandraクラスタが構成されている様子が図\ref{fig:ring}である。
% 図の例

% 図の例
\begin{figure}[h]
 \begin{center}
  \includegraphics[bb=0 0 567 580,width=\columnwidth]{img/tcpdump.png}
  \caption{{\tt tcpdump}の実行結果}
  \label{fig:tcpdump}
 \end{center}
\end{figure}

\paragraph{{\tt tcpdump}の使用}
通信量の測定は{\tt tcpdump}を使用した。上述したようなCassandraノードのプライベートネットワーク上で飛び交う、パケットを記録した。具体的にはTCPパケットのパケットサイズを記録した。また、{\tt tcpdump}に以下のオプションをつけて実行した。取得するパケットは二つの条件でフィルターをかけた。
\begin{itemize}
\item {\tt src net 10.20.0.0/16}\\
このフィルターにより、指定したデバイスを経由したパケットのうち、送信元が10.20.0.0/16のネットワークであるパケットのみが取得する。つまり、これで、このネットワーク以外のパケットを取得しないことになる。この条件で、余計なARPクエリなどを弾ける。
\item {\tt  dst net 10.20.(マシン番号).0/24}\\
このフィルターにより、指定したデバイスを経由したパケットのうち、受信元が10.20.(マシン番号).0/16のネットワークであるパケットのみが取得できる。つまり、{\tt tcpdump}を実行するマシンで実行するCassandraノード宛のパケットだけを取得することができる。
\end{itemize}
この2つの条件により、他のマシンで起動しているCassandraノードからこのマシンで起動しているCassandraノードに送られてくるパケットだけを取得できるのである。図\ref{fig:tcpdump}が{\tt tcpdump}を実行したときの実行結果の例である。





\paragraph{同じマシン上で動作しているCassandraノード同士の通信は取得できない}
一方、{\tt tcpdump}で測定する方法では同じマシン上で動作しているCassandraノード同士の通信は取得できないことに留意したい。



\subsection{通信量の推定}
\subsubsection{実験1:gossipの通信量の推定}
{\tt tcpdump}を使用した上のような計測方法では、同じマシン上でのCassandraノード同士の通信を計測することはできない。そこで我々は以下の仮定をもとに、計測した通信量からCassandraノードで発生するgossipの通信量を推測することにした。
\begin{itemize}
\item 仮定: 同じマシン上で動作するCassandraノードとの通信量の平均と異なるマシン上で動作するCassandraノードとの通信量の平均は等しい
\end{itemize}

各Cassandraノードから見れば、同じマシン上で動作するCassandraノードも異なるマシン上で動作するCassandraノードも区別はないので、この過程は妥当である。
この仮定から、測定できないマシン内部での通信量をマシンをまたいだ通信を計測することで、推定が可能になる。

gossipの通信量の推定について説明する。$m$台の各マシンでcassandraを$n'$ノード (ただし、$n'>2$とする) 起動する。つまり、システム全体で合計$n \times m$ノードのCassandraが起動されている。各マシンで{\tt tcpdump}を使用して計測した得られた通信量の合計を$T_t$とし、推定するCassandraノードで発生する通信量$T$とする。$T_t$は、$(n -1) \times m$ノードのCassandraから取得した$n \times m$ノードの合計通信量である。上の仮定を用いると、$((n \times m) - 1$ノードから取得する通信量$T$は、
\begin{eqnarray}	
T &=& T_t \times [ (n' \times m ) - 1  / ( (n' - 1 ) \times m ) ] 
\label{eq:infer_gossip}
\end{eqnarray}	

とCassandraノードで発生するgossipの通信量を推測することができた。

具体的に$n=4, m=2$の時を例に取り上げる。つまり、マシン2台上でそれぞれCassandraを2ノードを起動する状況を考える。
 (図\ref{fig:infer-gossip-traffic}) 
また、各マシンは受信する通信量しか計測していないことに注意する。

このとき、測定可能な通信量から、測定不可能な通信量を見積ればよい。
マシンAが測定しているのは、ノード3, 4からノード1への通信とノード3, 4からノード2への通信
である。
同様にマシンBが測定しているのは、ノード1, 2からノード3への通信とノード1, 2からノード4への通信である。それぞれ、$T^A$, $T^B$とおく。
また、測定出来ていないのは、ノード1からノード2、ノード2からノード1、ノード4からノード3、ノード3からノード4の通信である。
これをまとめて$T^C$とおく。
$T^A$, $T^B$, $T^C$はともに4つのCassandraノード同士の通信の合計である。

上の仮定を利用すると、$T^C$は、マシンA、Bで測定した通信から見積もることができる。つまり、
\begin{equation}
	T^C = (T^A + T^B) /2
\end{equation}

よってCassandraノード間で発生する通信は、
\begin{eqnarray}	
	T &=& (T^A + T^B) / 2 + T^A + T^B\\
	&=& (T^A + T^B) \times 3 /  2\\
	&=& (T^A + T^B) \times (2 \times 2 -1) / [(2-1) \times 2]
\end{eqnarray}

と推測できる。これは式\ref{eq:infer_gossip}にしたがう。

\begin{figure}[h]
  \begin{center}
  \includegraphics[bb=0 0 720 540 , width=\columnwidth]{img/infer-gossip-traffic.png}
  \caption{gossip通信量の推定}
  \label{fig:infer-gossip-traffic}
    \end{center}
\end{figure}



\subsubsection{実験2:データ読み書きの通信量の推定}
次にデータ読み書きの通信量の推定方法について考える。
まず、Cassandraのデータ読み書き時の通信手順を説明する。
クライアントと直接データの受け渡しを行うCassandraノードをproxyノードと呼ぶ。
書き込み時には、proxyノードから担当ノードへデータが転送され、担当ノードはproxyノードにデータ書き込みが成功したことを知らせる、いわゆるAckを返す。
読込時には、proxyノードが担当ノードに読み込みリクエストを転送し、受信した担当ノードがデータを転送する。

つまり、データ読み書きがある場合に発生する通信の種類は、データの転送、データ書き込み成功のAck, 読み込みのリクエスト、そしてgossipによる通信の4種類である。実験2でGossipの通信量は測定しているので、計測した通信量から差し引くことで推定ができる。
またgossipの通信は、メンバー構成が安定しているときにはデータの読み書きによらず一定であることに留意する。

まず、YCSBクライアントの動作について説明する。
YCSBのクライアントは、Cassandra1ノードだけと接続してデータの読み書きを行う。
データの読み書きのワークロードは選択できる。今回の実験では、読み書きが半々の比率であるワークロードを選択した。

データ通信量$T$を推定する。proxyノードが動作するマシンで取得した通信量を$T^A$, proxyノード以外のノードが動作するマシンで取得した通信量の合計を$T^B$として、それぞれgossipの通信量を$T^A_{gossip}$, $T^B_{gossip}$とおく。このときデータ通信量$T$は、
\begin{eqnarray}
T = [ ( T^A - T^A_{gossip} ) + ( T^B - T^B_{gossip} ) ] \times [ ( n-1) / n ] \times [ m /  ( m - 1 ) ]
\label{eq:eq_data-traffic}
\end{eqnarray}
で得られる。具体的に$n=4$、$m=2$の場合について説明していく。
書き込み時、読み込み時に分けて推定を行う。
実際は、読み書きのリクエストが混ざっているが、どちらも同じ式で推定できるため、式\ref{eq:eq_data-traffic}で十分である。


\paragraph{書き込み時}
\begin{figure}[!h]
  \begin{center}
  \includegraphics[bb=0 0 690 445 , width=\columnwidth, height=8cm]{img/infer-data-traffic1.png}
  \caption{データ通信量の推定  $ \sim $gossipの通信を含む$ \sim $}
  \label{fig:infer-data-traffic1}
    \end{center}
\end{figure}

\begin{figure}[!h]
  \begin{center}
  \includegraphics[bb=0 0 690 445 , width=\columnwidth, height=8cm]{img/infer-data-traffic2.png}
  \caption{データ通信量の推定   $ \sim $gossipの通信を含まず$ \sim $}
  \label{fig:infer-data-traffic2}
    \end{center}
\end{figure}

書き込み時に発生する通信は図 \ref{fig:infer-data-traffic1}にあるように、gossipの通信、データ書き込みの通信、$ack$の通信の3つである。proxyノードが動作するマシンで取得した$ack$の通信量を$T^A_{ack}$, proxyノードがないマシンで取得したデータ書き込みの通信量の合計を$T^B_{data}$とおく。すなわち
\begin{eqnarray}	
	T^A &=& T^A_{gossip} + T^A_{ack}\\
	T^B &=& T^B_{gossip} + T^B_{data}
\end{eqnarray}
が成立している。
各マシンで取得した通信量からgossipの通信量を差し引く。これはデータの読み書きに応じてgossip通信量が変化しないことから問題ない。
またgossipの通信量は、データの読み書きをする前後で計測可能である。
gossipによる通信を除いた通信は、proxyノードからproxyノード以外へデータを転送する通信と、proxyノード以外のノードからproxyへの$ack$の通信である。
これを表したのが図\ref{fig:infer-data-traffic2}である。このとき、Cassandraノード全体で発生するackの通信量を$T_{ack}$とおけば、
\begin{eqnarray}	
	T_{ack} = T^A_{ack} \times 3 / 2
\end{eqnarray}
である。Cassandraノード全体で発生するデータ書き込みの通信量を$T_data$とおくと、
\begin{eqnarray}	
	T_{data} = T^B_{data} \times 3 / 2
\end{eqnarray}
である。一方、
\begin{eqnarray}	
	T = T_{ack} + T_{data}
\end{eqnarray}
であるので、
\begin{eqnarray}	
	T &=& ( T^A_{ack} + T^B_{data} ) \times 3 / 2\\
	 &=&  [ ( T^A - T^A_{gossip} ) + ( T^B - T^B_{gossip} ) ] \times 3 / 2
\end{eqnarray}
である。これは、式 \ref{eq:eq_data-traffic}にしたがう。

\paragraph{読み込み時}

\begin{figure}[p]
  \begin{center}
  \includegraphics[bb=0 0 690 475 , width=\columnwidth, height=8cm]{img/infer-data-traffic3.png}
  \caption{データ通信量の推定 $ \sim $gossipの通信を含む$ \sim $}
  \label{fig:infer-data-traffic3}
    \end{center}
\end{figure}

\begin{figure}[!h]
  \begin{center}
  \includegraphics[bb=0 0 690 475 , width=\columnwidth, height=8cm]{img/infer-data-traffic4.png}
  \caption{データ通信量の推定 $ \sim $gossipの通信を含まず$ \sim $}
  \label{fig:infer-data-traffic4}
    \end{center}
\end{figure}


読み込み時も同様である。読み込み時の通信の流れを図\ref{fig:infer-data-traffic3}に表した。読み込み時に発生する通信は、gossipの通信、データ読み込みの通信、データのリクエストの通信の3つである。gossipの通信を除いた通信の流れが図\ref{fig:infer-data-traffic4}である。
書き込み時におけるデータによる通信をデータのリクエストに、$ack$をデータによる通信に置き変えたのが読み書き時の通信の流れになる。
書き込み時と同様に、proxyノードが動作するマシンで取得したデータ通信量を$T^A_{data}$, proxyノードがないマシンで取得したリクエストの通信量の合計を$T^B_{request}$とおく。このとき、

Cassandraノード全体で発生するデータの通信量を$T_{data}$とおけば、
\begin{eqnarray}	
	T_{data} = T^A_{data} \times 3 / 2
\end{eqnarray}
Cassandraノード全体で発生するリクエストの通信量を$T_{request}$とおけば、
\begin{eqnarray}	
	T_{request} = T^B_{request} \times 3 / 2
\end{eqnarray}
一方、
\begin{eqnarray}	
	T = T_{data} + T_{request}
\end{eqnarray}
であるので、
\begin{eqnarray}	
	T &=& ( T^A_{data} + T^B_{request} )  \times 3 / 2\\
	 &=&  [ ( T^A - T^A_{gossip} ) + ( T^B - T^B_{gossip} ) ] \times 3 / 2
\end{eqnarray}
である。これは、式 \ref{eq:eq_data-traffic}にしたがう。


$n=4$、$m=2$の場合に、読み書き両方においてデータの通信量は、式 \ref{eq:eq_data-traffic}で推測できることが確認できた。




% 図の例
\begin{figure}[p]
 \begin{center}
  \includegraphics[bb=0 0 635 983 , width=\columnwidth]{img/mearsureScript.png}
  \caption{実行スクリプト}
  \label{fig:mearsureScript}
 \end{center}
\end{figure}
\section{通信量測定のためのプログラムの作成}
図\ref{fig:mearsureScript}のような自動で通信量の測定を行い、その後解析を行うプログラムを作成した。





\subsection{実験環境}
以下に実験環境を示す。
\begin{itemize}
\item Cassandra 0.6.6	
\item OS Linux	 2.6.35.10 74.fc14.x86\_64
\item CPU: 2.40 GHz Xeon E5620 × 2
\item Java仮想マシン: Java SE 6 Update 21
\item メモリー: 32GB RAM
\item ネットワーク: 1000BASE-T
\end{itemize}




