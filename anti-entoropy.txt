■タイトル
Efficient Reconciliation and Flow Control for Anti-Entropy Protocols
■概要
この論文は、アンチエントロピープロトコルが、限られた頻度の更新を処理できることを示し、(?)
またアンチエントロピープロトコルのフローコントロールスキーマと同じくらいよい新たな融合メカニズムを提案・評価した。

■intro
アンチエントロピー、gossipプロトコルは、強い一貫性のない状態を複製していく方法として
魅力的である。ほとんど制限がなく、ホストの故障やメッセージのロスがあったとしても、参加するメンバー数のlogのオーダー時間内に更新が伝わる。
更新伝搬のふるまいは、よく知られた伝搬解析テクニックとともに簡単にモデル化できる。
結果として、多くの分散アプリケーションがさまざまな一貫していな状態を含んでもよいのでゴシップを使用している。

その人気にもかかわらず、ゴシッププロトコルが更新ヘビーの状況下でどのように振舞うのかはあまり研究されていない。
ゴシッププロトコルでは、予め設定されたラウンド内で高い確率でメッセージを届けることができ、またそれ故、同期する保証を与えているということになっている。
他の動機コミュニケーションチャネルと同じように、ゴシップにも能力は限界がある
。ゴシップのデータをトランスポートするのに可能なバンド幅、ゴシップメッセージを作成、処理するCPUサイクルなどによる制約があるからだ。
更新ヘビーの状況では、ゴシッププロトコルは、ピアー同士の違いを融合する野に必要なすべての更新を送信することはできないかもしれない。
ゴシップチャネルが詰まれば、更新が伝搬する時間は、よくわからなくなる。(arbitrary)

ゴシッププロトコルは、それ自体あまり処理区が重くない、予想されるパフォーマンスであるようにデザインされている。
これについて、デザイナーは、参加者に対するゴシップする率だけでなく、ゴシップメッセージの最大サイズまで(つまり、最大UDPパケットサイズ)
を修正しなければならないだろう。一方、ネットワークやCPUの高負荷をさけるためには、gossipチャネルの能力を制限すれば良い。

この論文は、二つのコントリビューションをした。一つ目は、最小限のCPU負荷とネットワークバンド幅がかげられた状況を対象とした、新たな状態融合メカニズムを提供した。
ふたつめは、ゴシップのフローコントロールを提案、解析した。

● Gosssip Basecs
　gossipにはanti-entoropyとrumor-mongeringプロトコルの二つに分類できる。
・anti-entoropyプロトコルゴシップは、新たな情報によって、古い情報が不要になって時に限って、ゴシップを行う。
・Rumor-mongeringでは、高い確率で情報が参加者に行き渡るように十分に長い時間の間をもうけて、その期間でゴシップで情報交換をおこなわせる。
今回論文では、我々は,anti-entropy()に焦点を当てていく。なぜなら、rumor-mongeringプロトコルの情報の融合と制御フローについては、すでに十分研究されてきたからである。
(Section 5)

Let P = {p,q,…}を参加者の集合とする。各参加者は、状態を持っている。状態とは、我々をこれを
mapping σ <- S = K -> (V × N)
のことである。(モデル化した。)Kは、キーの集合であり、Vは、値の集合、Nは、有限のヴァージョンナンバーを表している。
σ(k) = (v,n)は、キーkは、v,nにマッピングされることを示している。
同じキーに対する最近のマッピングは、最大のバージョンを維持するようにするとする。
値と、バージョンの区間は、⊥(最小値)要素を含んでいおり、Nの場合は、⊥は、最小の要素である。
初期設定としては、すべての参加者に対するすべてのキーは、(⊥,⊥)にマッピングしている。

参加者の状態は、ミュータブル(変更可能である。)そして、すべての参加者間で複製化している。
我々はこれを以下のようにモデル化する。
mutable mapping 
Up: P -> S 
各参加者毎に保持している。(各自で二次元(p[メンバー],k[キー])のキーバリューリスト、変更可能なマッピング関数を保管している。)

参加者pは、Up(p)だけを直接更新することだけが許されている。
Up(q),q = p じゃ、ゴシップを通じて間接的にのみ更新できる。 

Anti-Entropyプロトコルは、s内の二つの状態についてmerge,reconcilationオペレーターである ×　を用いて、新しい状態を決定する。
このセマンティクス( σ = σ1 * σ2 ) は、以下のように行われる。
　σ1(k) = (v1,n1) 
 σ2(k) = (v2,n2)
とする。このとき、
もし、 n1 >= n2 であるならば、σ(k) = (v1,n1)
そうでないならば、σ(k) = (v2,n2)となる。

各参加者ｐは、peer Fp ⊆ P - {p}の集合を管理している。(この集合のピアーとゴシップするということ)
多くのプロトコルでは、Fp = P - {p}である。(全対全というこねね。)
定期的に、pは、ある参加者pをFpからランダムで選択して、ｑとゴシップを行う。ｐとqは、reconcilationオペレータを各参加者状態のコピーに適応する。

使用されるgossipには三つの種類がある。
多くの基本的な方法では、pは単純に、Upをqに送信し、qは、*オペレータをすべてのUq内のmappings(σ(k) = (v,n))に適応する。
つまり、
∀s: U'q( r) = uq(s) * up (s)
を適応するということである。これは、しばしば、「push gossip」と言われる。(更新されうるおは、Uｑか。)

「Pull gossip」では、pはqにｐの状態のダイジェストを送信する。つまり、値だけを除いてキーとバージョンナンバーだけのupを送信するのである。
qは、upの更新な必要な部分だけを返し、必要のない値を送信するのを防ぐ。(つまり、更新されるのは、Upだけ)

「Pull Push protocol」では、次の点をのぞいて、pull型のgossipと似ている。ｑもまた、ｐと比較して古くなった参加者キーのリストを送信することである。
受信するとすぐに、pは、それに一致するUpのエントリーをqに送り返す。Push-Pullがたは、もっとも効果的なスタイルで、我々が今論文で焦点を当てるものである。

もし、特定の参加者の特定のキーがもはや更新されないならば、その値は、すべての他の参加者に、予測された時間内に伝搬される。
また、logのオーダ時間内で伝わるし、また確率１(Fp十分に大きくとれば)で参加者全員は、イベンチュアリーに知ることができる。

単純に思われうが、CPUサイクル、ネットワークバンド幅が限られた状況下で、高い更新負荷がかかるじょうきょうっかでゴシップを使用するときには、トリッキーな問題が上がってくる。
gossipによる交換は、CPUとネットワークのリソースを使用する。しかし、ほとんどの公開されたワークには、これらのことはほとんど無視されている。
更新データの量が重要ならば、(ネックなら？)未消化処理が積み重なってくる可能性がある。

各参加者は、更新を同じ割合で更新を紹介する。予測される遅延は、ログのオーダーでスケールしていく一方で、gossipメッセージのサイズは、オーダーNでリニアーに増加していく。
実際、ゴシップメッセージの最大サイズは、メッセージを生成し、処理するCPU時間のようなその他や、gossipプロトコルが使用するかもしれないネットワーク幅の最大値によって限定されてしまう。これは、gossipメッセージが効果的に利用されることが重要であること、更新の比率は慎重にコントロールしなければならないことを示している。
もし更新頻度が高いならば、遅延は、アンバウンドに(時間制限なしに)遅延がますかもしれない。

実際、我々は更新の頻度を限定することは、アプリケーションの問題にとっては、更新のレイテンシーの問題より大した問題ではないと思う。
ゴシップされた情報は、ある時間間隔でサンプルされる。アプリケーションは、概して、どれくらいの頻度でサンプルされるかとというより、情報の最新であるかどうかに興味がある。

この論文では、我々はゴシップメッセージには、多くても全体でMTUで制限されたサイズのタプルのセットが含まれている。各タプルは、参加者p,キーk,値v,バージョンナンバーnで構成される。
これは、過去のある時刻で、Up(k)( p) = (v,n)であることを意味している。我々は、このようなタプルをデルタスと呼ぶ。
(実際、異なるデルタスは、異なるサイズを持っている。しかし、これは複雑化する主な要因にはならない。)


3.融合
 二人の参加者p,qは、融合メカニズムpiを使ってゴシップを行うとき、ｐは結局ｑに、デルタス(⊿pi p->q ⊆ {(r,k,v,n) | up®(k = (v,n))})のセットを送信し、
いっぽうで　、ｑは、ｐに同じような集合⊿pi q->pを送信する。もし、|⊿pi p->q | >mtuであるば、mtuサイズのサブセットだけが送信されてしまうかもしれないし、⊿pi q->pも同じことが言える。

[mtuにより、gossipでメッセージがかげられている、どのタプルを送信すべきか？というおはなし。mtu制約が絶対ならば、古いデルタスを送らないのも手だね。ということか。]
どのデルタスを送信するかを決めるために、デルタスは <piによって全順序で順序付けられていなければならない。つまり、異なる二つの要素デルタスφ1 <pi デルタスφ2 または、
デルタすφ2 <pi デルタすφ1かが定まらなければならない。mtuが大きいmtuデルタス群だけが、ゴシップメッセージに含まれる。可能性のある融合メカニズムの順序付けは、正確性と必要性によって制約されるかもしれない。これらの制約の中で、異なる順序付けは、異なるパフォーマンスへと導かれる。(となって現れる。指標がいっぱいあるのだろうね)我々があとでデモする。



我々は、二つの異なる融合メカニズムを今提唱する。一つ目は、正確な融合であり、必要な更新だけを送信し、ベースラインの測定に使用される。
次に提唱するのは、我々独自のメカニズム、scuttlebuttである。

3.1　正確な融合
正確な融合では、二つの参加者がゴシップによる交換を通じて、正確に他のピアが持っている情報よりも最新であるマッピング群を送る。
このようにして、もし、参加者がｐ,qであるとき、ｐがｑに以下のデルタスのセットを送る。

⊿precise p->q =  {(r,l,v,n) ∈ P × K × V × N |  up( r)(k) = (v,n) ∧ uq ( r)(k) = (・,n') ∧ n > n n'}
(つまり、デルタスの中で、ｑよりｐが最新の情報を持っているデルタスだけを送るってことか。)
(qにおくる前にどうやって知る？ -> そのソリューション(send a digest)は後述)

一方、ｑはpに同様のΔprecise q->pを送る。

受信すると、ｑは、⊿precise p->qを使って、uq( r)を更新する。
並行的なゴシッププロトコル活動によって、すべてのエントリーは更新されないかもしれないし、つまり、バージョンナンバーが並行的なuq( r)のなｋのそれよりも大きなものだけに更新が適応される。同様なことがΔprecise q->pで行われる。

実際、正確な融合はかなり難しい。参加者同士の違いを決定するために、参加者同士の状態のダイジェストが交換されなけばならない。
先ほど記述したように、またΔprecise p->qやΔprecise q->pの定義方明らかのように、これたには、値を含まない状態を送ることが可能である。
だがこれは、かなりのデータ量を未だおり、また圧縮スキーム(ハッシュ)もCPUサイクルのsignificantnaな量を消費していしまう。

[更新する必要があるデルタスもすべて送信できるとはかげらない。]
どのように、あるmtuが強制されているケースにおいて、ベストな結果となるようにこれらのデルタスから順序付けを行うかというかとは明らかでない。
順序付けは、ランダムにor決められた形で行われるかもしれない。
この論文では、我々は二つの決定的なアプローチを提案のベースたいんとする。
「正確ー１番古い」アプローチにとっては、ゴシップメッセージのなかに、最も古いデルタスが含まれいる。
「正確ー１番新しい」アプローチいとっては、もっとも最近の更新がそのかわりに使用される。
後者は、枯渇つまり、ある古い(方の)更新が伝搬される可能性が与えられないこととなる可能性がある

注意して欲しいのは、実装されるには、両方の順序付けにおいて、メンバー間で同期するクロックが必要なことである。
そのクロックによって、すべての更新はアップデートされなければならない。

3.2 scuttlebutt融合

次に我々は、正確な融合よりも使用されるネットワークバンド幅と消費されるCPUサイクルの両方で効果的な融合なメカニズムを提案する。
まず、max(σ)をσ ∈　Sにおけるバージョンナンバーの最大値とする。また、参加者pは、”一度に”σp = up( p)の状態だけ更新することが許されているとする。
つまり、参加者は、キーk0の値をv0に更新し、新たな状態σ'pを作成したいとする。

scuttlebuttでは、参加者が以前に使用したよりも大きいバージョンナンバーを使用することが求める。つまり、
σp′ (k0) = (v0, n0) where n0 > max(σp), and σp′ (k) = σp(k) for all k ≠	k0
(k0の値だけを交換して、後は同じ。)
結果として、どの異なる二つキーが同じバージョンナンバーになることが不可能になる。

pとqがゴシッピングを開始したとき、これらはまずはじめにダイジェストを交換する。
dijests: {(r,max(μp(r))) | r ∈ P} and {(r,max(μq(r))) | r ∈ P}
(最初のがpからqに共有するもの、後のが、qかたpに共有するもの)
受信するとすぐにpからqに

⊿scuttle p->q =  {(r,k,v,n) | μp(r)(k) = (v,n) ∧ n > max(μq(r))}

また、qは、同様の⊿scuttle q->pをpに送り返す。

ゴシップをするモジュールは、決して、受信者ですでに知られている更新を送信することはない。
もし、ゴシップメッセージにサイズの制限がなければ、このセットは、「正確な融合」と同様に正確に違いを含んでいる。
もし、このセットがゴシップメッセージに収まりきらないときは、「正確な融合」のように、気まぐれなサブセットを使用することは許されていない。
Scuttlebuttでは、もし、あるデルタス(r,k,v,n)が送信することができないならば、rについて高いバージョンをもつデルタスすべてを送信しない(省略する)
(最新のを送信しないということか？)
我々は、デルタス間の順序付けに制約を加えために、以下を強制する。

n > n′ ⇒ (r,k,v,n) <scuttle (r,k′,v′,n′)
(デルタス同士を全順序にする。)

Scuttlebuttは、いかなるp,qの二つのプロセスに対して、グローバルな不変条件C(p,q)を満足する。

不変条件C(p,q) ≡ ∀k ∈ K :  μp(p)(k) = μq(p)(k) ∨	up( p)(k).n > max (up ℗)

つまり、各プロセスqは、現在のpに関するキーｋに対するマッピングをもっているか、あるいは、現在のｋのバージョンは、は、qがｐに関して持っているバージョンの最大値よりも大きい。
最初は、すべてのプロセスのすべてのキーが(⊥,⊥)にマッピングされているので、⊥は可能性のある最小バージョンナンバーになる、ｋの不変条件は、システムの初期状態も含んでいる。
あらゆる時刻で、C(p,p)が成立するのは明らかであるので、ローカルのマッピングへの更新の際も不変条件を満足する。
最後に、プロセスpとプロセスqの間における、マッピングrのゴシップ交換が不変条件をみたすことをいう。つまり新しいバージョンのup( r)が、C(r ,p )を満足するし、
また、新しいバージョンのuq( r)が、C(r ,q )を満足するのである。(実際は、二つのテーブルのうち最大でも一つが更新されるだけである。更新されるのは最大のバージョンが古い方である。
)なので、古いバージョンをもつデルタスが交換されることが重要である。もしそうでないのであれば、不変条件p,qは、



Scuttlebuttの特筆すべき性質は、二つの参加者間で行われるゴシップ通信は、もし、ゴシップメッセージに十分の余地があったとしても、二つのすべての違いを埋めようとするものではないことである。
図１を例として取り上げる。このテーブルは、参加者p,qにおける参加者ｒの状態の一部(a,b,c)を表したものである。時刻t=1,t=2の間では、p,rは、qとｒと同様に一つのΔを交換することができる。時刻t=2では、 max(μp®)とmax(μq®)が同じなので、pとqはゴシップし、qは、ｐに最も最新のエントリーを贈ろうとしない。

これは、欠点いみえるかもしれない。「正確な融合」がすべての違いを埋めることができ、それゆえ潜在的に早く一つの値に収束することができる。
しかしながら、この埋められた違いはすでにrで更新され、それゆえ、再び融合されるキーに関するものである。
必要のない更新を送信しないことで、ゴシップメッセージ内に他の参加者のデルタスのための余地をのこしているのである。

不変条件C(p,q)を考慮すると、次の特性も成立している。なぜなら、pのどのキーもmax(μp ℗)より大きいものを持っているからである。

max(μq(p)) = max(μp(p)) ⇒ μq(p) = μp(p)

これは交換をするたびに、必要のない更新をすることなく、一貫した状態へscuttlebuttが近付くことが明らかになる。

以下、

n > n′ ⇒ (r,k,v,n) <scuttle (r,k′,v′,n′)

のバリエーションについて議論している。
----
我々は、二つの可能性のある順序付けを提案する。
Scuttlebreaddth順序付け関数は、可能な限りの異なる参加者からのデルタスを各ゴシップメッセージに含めることで、
すべての参加者にたいしてフェアーであり続けようとする。
同じ参加者のデルタ素については、ランキングを行う。最も小さい数値をもつΔが、ランク０、次に小さい値が１などである。
このデルタスは、はじめに、小さいランクをもデルタスが大きいランクをもつデルタスより優先して、含まれるように順序付けを行う。
同じランクをもつ２つの異なるデルタスにとって、それゆえことなる参加者には必然的に、順序付けは、参加者同士の順序付けに基づくことになる。
この順序付けは、各ゴシップ交換が長い期間のバイアスを埋めるように異なるえきだし、我々の実験では、各ゴシップメッセー次でことなる擬似ランダムな順序付け
をしようした。今順序付けは<Scuttleの制約をようにに満足死することに留意する。

我々が提案する他の順序付け関数は、
----

3.3 評価
この融合戦略を評価するために、われわれはさまざまなシミュレータを負荷シナリオのもと動作させた。128の参加者がいて、各自64のキーバリューペアを保持しているとする。
各参加者は、１秒あたり一回のゴシップを行う。各参加者と同じのあるレートで、値は更新される。またその値は、均一にアトランダムとする。

この実験は、t=0の時刻からスタートする。参加者pあたりの初期の更新レートρは、1%とする。最初の１５秒のシュミレーションでは、メッセージのサイズ制限は強制されず、
バイアスを除くためにシステムをウォームアップさせる。この後に、メッセージ制限を強制させる。t=25でレートを倍にして、t=75でレートを元に戻す。
t=120で更新を終了させ、システムがある一つの状態になるようにさせる。

不変条件C(p,q)を考慮すると、以下の性質をもつ。なぜならｐのすべてのキーがmax(up( r))よりおおきいバージョンナンバーを持たないからである。
max(μq(p)) = max(μp(p)) ⇒ μq(p) = μp(p)

 Scuttlebuttが毎回の交換ですべての更新を不必要に行わなくても一貫した状態へ収束することは明らかである。

多数の順序付けが等式1の制約を満足するが、これらは、ころなるパフォーマンス特性の結果である。




Figure2では、mtu=100として、最大に更新されていない状態が続くかどうかを典型的な実験のため時間機能として報告したものである。
キーバリュマッピングu( p)(k)は、もし、μq (p)(k)	̸=	μp ℗(k)であれば、新鮮でない。
マッピングμq℗(k)のような更新されないままになっているのは、μq(p)(k) が最後に更新された時から放置されている時間の合計となる。

集約的な更新レートは,１秒あたり128の更新で、メッセージサイズ制限の内システムでは、我々は、平均のゴシップメッセージが更新のは分を含んでいることを期待する。
ゴシップによる交換の各方向にゴシップメッセージがあるように。このように、我々は、それぞれのプロと項るがよくうごき、実験が身を結んでいることを期待した。
下のような状況での遅延の分布は、だいたい5,6ラウンドのゴシップである。伝染病的な分析から由来するように。

t=25のとき、集約レートは256更新/secに二倍に花た。


4.フロー制御
ゴシップのフロー制御メカニズムの目的は、適応的に更新のバックログを作成することなく、更新を送信することが可能な最大レートを決定することである。
フロー制御メカニズムは公平であり、高い負荷がかかった状況でも、同じ更新レートで各参加が更新情報を伝達ｄけいる仕組みでないといけない。
グローバルな洞察はないが、風呂制御メカニズムは、非集中でなければならない、つまりそこでは、、望まれたふるまいが、ローカルエベントに反応する参加者から起きるのである。

モニターされているかもしれないローカルイベントは、ゴシップメッセージのオーバーフローである。時々のオーバーフローは、そんなにもんだいではにあ。
すべての融合プロと高ｒは、これらを処理することができる。しかしながあら、オーバーフローがますます悪い方向になっているという状況下では、参加者は、
更新を生成するのを控えなければならない。

孤律させることで、そのような線りゃき自体は、ある参加者を取り除くことで、他の参加者は、更新レータを挙げる。
そのような公平性を犠牲にすることで、我々はゴシップメカニズム自体を使用することができる。

二つの参加者がgossipするとき、それらは、現在の最大の更新レートをこうかんする。
要参加者が可能なかぎり最大れ＾戸で更新をしようと仮定するならば、それらは違いを分離し、各自は、いずれ同じ最大更新レートとなる。
これは、これらの古い更新レートの平均と同じである。この集約された更新レートは、変化しないが、システム全体としては、公平性をマス。
もし、参加者の一人が可能なかぎりの最大レートで更新を行わないならば、参加者は、更新レートをへらし、＠ピアーにリマインダーを送信する。




